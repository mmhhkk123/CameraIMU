package com.ru.cameraimu;

import android.app.Activity;
import android.content.Context;
import android.content.pm.PackageManager;
import android.hardware.Camera;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.os.Bundle;
import android.os.Environment;
import android.util.Log;
import android.view.Gravity;
import android.view.View;
import android.widget.FrameLayout;
import android.widget.TextView;
import android.widget.Toast;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;

public class MainActivity extends Activity {

  public static final boolean NEED_RECORD = true;
  public static final int DEFAULT_CAPTURE_W = 640;
  public static final int DEFAULT_CAPTURE_H = 480;
  public static final int INFO_VIEW_UPDATE_RATE = 10;

  public String mDateString;
  public String mStorageDir;

  // Sensor
  private Sensor mGyroscope;
  private Sensor mAccelerometer;
  private IMUEventListener mGyroListener;  // The gyroscope event listener
  private IMUEventListener mAcceListener;  // The accelerometer event listener
  private SensorManager mSensorManager;

  // Camera
  private Camera mCamera;
  private Boolean mIsCapturing = false;
  private CamCallbacks.ShutterCallback mShutterCallback;
  private CamCallbacks.PictureCallback mPictureCallback;
  private CamCallbacks.PreviewCallback mPreviewCallback;

  // UI
  private TextView mInfoView;

  // Debug
  private final String TAG = "TAG/CameraIMU";

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    Log.i(TAG, "onCreate");
    super.onCreate(savedInstanceState);

    Context context = getApplicationContext();
    setContentView(R.layout.activity_main);

    mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
    mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
    mGyroscope = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);

    if (mAccelerometer == null || mGyroscope == null) {
      Toast toast = Toast.makeText(context, R.string.fail_to_load_imu, Toast.LENGTH_SHORT);
      toast.show();
      finish();
      return;
    }

    if (!isExternalStorageWritable() && NEED_RECORD) {
      Toast toast = Toast.makeText(context, R.string.failed_to_access_external_storage, Toast.LENGTH_SHORT);
      toast.show();
      finish();
      return;
    }

    if (!checkCamera()) {
      Toast toast = Toast.makeText(context, R.string.failed_to_access_camere, Toast.LENGTH_SHORT);
      toast.show();
      finish();
      return;
    }

    getCameraInstance();
    if (mCamera == null) {
      Toast toast = Toast.makeText(context, R.string.failed_to_access_camere, Toast.LENGTH_SHORT);
      toast.show();
      finish();
    }

    mGyroListener = new IMUEventListener(this, IMUEventListener.TypeE.G);
    mAcceListener = new IMUEventListener(this, IMUEventListener.TypeE.A);

    ((FrameLayout) findViewById(R.id.cam_layout)).addView(new CamPreview(context, mCamera));
    mInfoView = (TextView) findViewById(R.id.info_view);

    mShutterCallback = new CamCallbacks.ShutterCallback();
    mPictureCallback = new CamCallbacks.PictureCallback(this);
    mPreviewCallback = new CamCallbacks.PreviewCallback(this);
  }

  @Override
  public void onStart() {
    Log.i(TAG, "onStart");
    super.onStart();
  }

  @Override
  protected void onResume() {
    Log.i(TAG, "onResume");
    super.onResume();
    mSensorManager.registerListener(mGyroListener, mGyroscope, SensorManager.SENSOR_DELAY_FASTEST);
    mSensorManager.registerListener(mAcceListener, mAccelerometer, SensorManager.SENSOR_DELAY_FASTEST);

    getCameraInstance();
    setCamFeatures();

    Camera.Size previewSize = mCamera.getParameters().getPreviewSize();
    Context context = getApplicationContext();
    Toast toast = Toast.makeText(context, previewSize.width + " x " + previewSize.height, Toast.LENGTH_LONG);
    toast.setGravity(Gravity.CENTER, 0, 0);
    toast.show();
  }

  @Override
  protected void onPause() {
    Log.i(TAG, "onPause");
    super.onPause();
    mSensorManager.unregisterListener(mGyroListener);
    mSensorManager.unregisterListener(mAcceListener);

    releaseCamera();
  }

  @Override
  protected void onStop() {
    Log.i(TAG, "onStop");
    super.onStop();
  }

  @Override
  protected void onDestroy() {
    Log.i(TAG, "onDestroy");
    super.onDestroy();
  }

  public Boolean isCapturing() {
    synchronized (mIsCapturing) {
      return mIsCapturing;
    }
  }

  public CamCallbacks.ShutterCallback getShutterCallback() { return mShutterCallback; }
  public CamCallbacks.PictureCallback getPictureCallback() { return mPictureCallback; }

  public void printSensorInfo(long timestampNanos) {
    mInfoView.setText("Sensor Information:\n");

    IMUEventListener.DataTupleT gyroData = mGyroListener.getCurrentTuple();
    IMUEventListener.DataTupleT acceData = mAcceListener.getCurrentTuple();

    mInfoView.append(String.format(Locale.US, "GX: %08.6f\t\tAX: %08.6f\n", gyroData.x(), acceData.x()));
    mInfoView.append(String.format(Locale.US, "GY: %08.6f\t\tAY: %08.6f\n", gyroData.y(), acceData.y()));
    mInfoView.append(String.format(Locale.US, "GZ: %08.6f\t\tAZ: %08.6f\n", gyroData.z(), acceData.z()));
    mInfoView.append(String.format(Locale.US, "Timestamp Nanos: %d", timestampNanos));
    if (mIsCapturing)
      mInfoView.append(String.format(Locale.US, "\nCurrent FPS: %.2f", mPreviewCallback.getCurrentFPS()));
  }

  public void onCaptureBtnClick(View view) {
    if (!mIsCapturing) {
      if (NEED_RECORD) {
        mDateString = (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.US)).format(Calendar.getInstance().getTime());
        mStorageDir = getResources().getString(R.string.app_name) + File.separator + mDateString;
        File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS),
                             mStorageDir + File.separator + "IMG");
        if (!file.mkdirs()) {
          Context context = getApplicationContext();
          Toast toast = Toast.makeText(context, R.string.failed_to_access_external_storage, Toast.LENGTH_SHORT);
          toast.show();
          return;
        }
      }

      synchronized (mIsCapturing) { mIsCapturing = true; }

      Context context = getApplicationContext();
      Toast toast = Toast.makeText(context, R.string.start_capturing_msg, Toast.LENGTH_SHORT);
      toast.show();
      mCamera.setPreviewCallback(mPreviewCallback);
    } else {
      synchronized (mIsCapturing) { mIsCapturing = false; }

      Context context = getApplicationContext();
      Toast toast = Toast.makeText(context, R.string.stop_capturing_msg, Toast.LENGTH_SHORT);
      toast.show();
      mCamera.setPreviewCallback(null);
      if (NEED_RECORD) {
        mGyroListener.flushData();
        mAcceListener.flushData();
      }
    }
  }

  private boolean isExternalStorageWritable() {
    String state = Environment.getExternalStorageState();
    return Environment.MEDIA_MOUNTED.equals(state);
  }

  private boolean checkCamera() {
    if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA))
      return true;
    else
      return false;
  }

  private void getCameraInstance() {
    if (mCamera == null) {
      try {
        mCamera = Camera.open();
      } catch (Exception e) {
        Log.e(TAG, "getCameraInstance: " + e.getMessage());
      }
    }
  }

  private void releaseCamera() {
    if (mCamera != null) {
      mCamera.release();
      mCamera = null;
    }
  }

  private void setCamFeatures() {
    Camera.Parameters params = mCamera.getParameters();

    List<String> focusModes = params.getSupportedFocusModes();
    if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
      params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
      mCamera.autoFocus(null);
    }
    List<String> flashModes = params.getSupportedFlashModes();
    if (flashModes.contains(Camera.Parameters.FLASH_MODE_OFF))
      params.setFlashMode(Camera.Parameters.FLASH_MODE_OFF);
    List<String> whiteBalanceModes = params.getSupportedWhiteBalance();
    if (whiteBalanceModes.contains(Camera.Parameters.WHITE_BALANCE_DAYLIGHT))
      params.setWhiteBalance(Camera.Parameters.WHITE_BALANCE_DAYLIGHT);

    params.setPreviewSize(DEFAULT_CAPTURE_W, DEFAULT_CAPTURE_H);
    params.setPictureSize(DEFAULT_CAPTURE_W, DEFAULT_CAPTURE_H);

    mCamera.setParameters(params);
  }
}
